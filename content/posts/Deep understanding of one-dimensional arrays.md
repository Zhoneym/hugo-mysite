---
title: "深入理解一维数组" 
date: 2019-07-21T18:12:15+08:00
tags: ["C++"]
draft: false
---

一维数组的原理可以概括为以下几点:

1. 内存布局

一维数组在内存中是以连续的形式存储的,数组的每个元素占用相同的内存空间(由元素类型决定),并按索引顺序依次排列。

例如,声明int array[5]; 在内存中可以表示为:

| 数组元素 | 内存地址 |
| --- | --- | 
| array[0] | 0x0100 |
| array[1] | 0x0104 |
| array[2] | 0x0108 |
| array[3] | 0x010C |
| array[4] | 0x0110 |

每个int类型占4字节内存,所以元素索引与内存地址之间有4字节的间隔。

2. 数组名

数组名表示整个数组,它存储的是数组第一个元素的内存地址。 

例如数组名array存储的值是0x0100,就是第一个元素array[0]的地址。

3. 索引访问

数组的索引顺序从0开始,最大索引为数组长度减1。

通过索引可以直接访问到对应元素在内存中的位置。例如array[2]就可以直接访问到内存地址为0x0108的那个元素。

数组索引到内存地址的转换公式为:

地址 = 数组起始地址 + 索引 * 每个元素的大小

4. 固定长度

数组长度在声明时就已确定,不可以改变。想要更改数组长度,必须重新声明一个新的数组。

5. 连续分配

一维数组占用的是内存中一段连续的空间,这使访问效率非常高。但是如果需要插入或删除元素,就需要移动后续元素。

6. 类型统一

数组中的每个元素必须是相同的数据类型,不允许混合不同类型。


如何理解 数组名是指向数组首元素地址的指针常量,这句话表达了两个概念:

1. 数组名表示地址

数组名表示整个数组在内存中的起始地址,也就是数组第一个元素的地址,它是一个指针常量。

2. 不可修改指针

数组名是一个指向数组第一个元素的不可修改的指针,也就是常量指针。

下面通过一个例子说明:

```c
int arr[10]; 
printf("%p\n", arr); // 打印数组起始地址
printf("%p\n", &arr[0]); // 打印第一个元素地址

```

数组名arr表示数组的起始地址,它无法进行指针运算。

但我们可以通过正常指针去访问数组:

```c
int* p = arr; // p指向数组起始地址，也就是 &arr[0]
p++; // 指针运算 Ok
```

所以总结:

- 数组名表示数组首地址,是常量指针
- 不能对数组名进行指针运算
- 可以用普通指针变量存储数组地址进行操作


数组是一个固定大小的数据结构,不可以直接对数组进行增删操作。但是通过一些特殊的方法,仍然可以模拟在数组上实现:

1. 增加元素

由于数组大小不可变,无法直接在尾部追加元素。一种方法是声明一个更大的新数组,将原数组拷贝过去,再添加新元素。

```cpp
// 原数组
int arr[5] = {1, 2, 3, 4, 5}; 

// 声明新数组
int newarr[6];

// 拷贝原数组到新数组
for(int i=0; i<5; i++)
  newarr[i] = arr[i]; 

// 在新数组尾部添加元素  
newarr[5] = 6;
```

2. 删除元素

无法直接删除数组元素,一种方法是把要删除元素后的所有元素向前移动一个位置覆盖。

```cpp
int arr[5] = {1, 2, 3, 4, 5};

// 删除索引为2的元素 
for(int i=2; i<4; i++)
  arr[i] = arr[i+1];
``` 
使用元素前移的方法删除数组中的一个元素,确实会产生一定的内存浪费。

具体来说,当我们把要删除元素后面的所有元素都向前移动一个位置时,原数组最后一个位置就会变为空,产生了浪费。

例如原数组:

[1, 2, 3, 4, 5]

我们要删除索引为2的元素3。前移后数组变为: 

[1, 2, 4, 5, ?]

可以看到原数组最后一个位置现在是空的,但是它仍然占用着内存空间。这会造成一定程度的浪费。

如果要避免这种浪费,我们需要进行数组缩容,也就是减小数组长度,释放多余的内存。

上例中,我们可以这样缩容:

```cpp
int arr[5] = {1, 2, 3, 4, 5};

// 删除第3个元素
for(int i=2; i<4; i++)
  arr[i] = arr[i+1]; 

// 缩容数组长度
int newLen = sizeof(arr) / sizeof(arr[0]) - 1; 
int newArr[newLen];

// 拷贝到新数组
for(int i=0; i<newLen; i++)
  newArr[i] = arr[i];
```

这样就删除了要删除的元素,又释放了最后一个元素的内存占用。

3. 修改元素

直接通过索引修改即可:

```cpp 
arr[2] = 999; // 修改索引为2的元素
```

4. 查询元素

直接通过索引访问即可:

```cpp
int num = arr[3]; // 查询索引为3的元素
```

数组分割是指将一个数组拆分成两个或者多个较小的数组的操作。主要有两种数组分割的方法:

1. 连续分割

这种方法是将原数组按照下标连续分割成多个数组,例如:

```cpp
int arr[8] = {1,2,3,4,5,6,7,8}; 

int arr1[4]; // 拆分后的第一个数组
int arr2[4]; // 拆分后的第二个数组

// 拷贝数组元素
for(int i=0; i<4; i++)
  arr1[i] = arr[i]; 

for(int i=4; i<8; i++)
  arr2[i-4] = arr[i];
```

上面代码将长度为8的数组arr,连续分割成了两个长度为4的数组arr1和arr2。

2. 间隔分割

这种方法是将原数组按照一定间隔拆分成多个数组,例如:

```cpp
int arr[8] = {1,2,3,4,5,6,7,8};

int arr1[4]; 
int arr2[4];

for(int i=0; i<8; i+=2)
  arr1[i/2] = arr[i];

for(int i=1; i<8; i+=2)
  arr2[(i-1)/2] = arr[i]; 
```

上面代码是将arr中奇数索引元素放入arr1,偶数索引元素放入arr2

在数组中交换两个元素的位置可以通过数组索引实现。主要有两种方法:

1. 使用临时变量

利用一个临时变量存放要交换的一个元素,然后覆盖另一个元素,最后再将临时变量的值赋给第一个元素。

```cpp
int arr[5] = {1, 2, 3, 4, 5};

// 交换索引 2 和 4 的元素
int temp = arr[2];
arr[2] = arr[4]; 
arr[4] = temp;
```

2. 交换变量值

通过一个交换变量值的函数,传入两个元素的索引,直接交换两个索引对应的元素值。

```cpp
void swap(int arr[], int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

int arr[5] = {1, 2, 3, 4, 5};
swap(arr, 2, 4); // 交换索引2和索引4的值
```

遍历:

时间复杂度为O(n)

1. 使用for循环遍历

```cpp
int arr[5] = {1, 2, 3, 4, 5};

for(int i = 0; i < 5; ++i) {
  cout << arr[i] << endl; 
}
```

2. 使用范围for循环遍历

```cpp
int arr[5] = {1, 2, 3, 4, 5}; 

for(int x : arr) {
  cout << x << endl;
}
```

3. 使用数组指针遍历

```cpp
int arr[5] = {1, 2, 3, 4, 5};

int* p = arr;
for(int i = 0; i < 5; ++i) {
  cout << *p << endl;
  ++p;
}
```
数组名是指向数组首元素地址的指针常量,不能对其进行++/--操作。要遍历数组,需要定义一个指针变量指向数组首地址:

```cpp
int* p = arr; // p指向数组首地址
```

然后利用指针的++操作对其进行遍历:

```cpp
++p; // 使p指向下一个元素
```

同时需要判断指针是否超出数组范围:

```cpp
i < 5 // i是索引控制变量
```

4. 使用数组名作为指针遍历

```cpp 
int arr[5] = {1, 2, 3, 4, 5};

for(int i = 0; i < 5; ++i) {
  cout << *(arr + i) << endl;
}
```


数组名是首元素地址,可以进行指针运算:

```cpp
arr + i
```

上面表达式的值是数组中索引为i的元素地址。

然后需要间接访问指针,输出元素值:

```cpp
*(arr + i)
```

再通过索引控制变量控制数组范围。

所以方法4使用了指针运算直接计算出每个元素地址,然后间接访问得到元素值,无需单独定义指针。

两种方法都是利用了指针运算遍历数组。

指针遍历可以与索引遍历统一理解:

索引i <==> 指针p+i

arr[i] <==> *(p+i) <==> *(arr+i)